<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Pr_Song&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Pr_Song&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Pr_Song">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Pr_Song's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pr_Song's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/SongPurong" class="github-corner" title="GitHub" aria-label="GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/23/Vue%E8%BF%87%E6%B8%A1-%E5%8A%A8%E7%94%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pr_Song">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pr_Song's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/23/Vue%E8%BF%87%E6%B8%A1-%E5%8A%A8%E7%94%BB/" class="post-title-link" itemprop="url">Vue过渡&动画</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-23 09:41:32 / 修改时间：09:43:27" itemprop="dateCreated datePublished" datetime="2020-07-23T09:41:32+08:00">2020-07-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡</p>
<ul>
<li>条件渲染 (使用 v-if)</li>
<li>条件展示 (使用 v-show)</li>
<li>动态组件</li>
<li>组件根节点</li>
</ul>
<p>当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：</p>
<ol>
<li>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。</li>
<li>如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。</li>
<li>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。</li>
</ol>
<h4 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h4><p>在进入/离开的过渡中，会有 6 个 class 切换。</p>
<ol>
<li><p>v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</p>
</li>
<li><p>v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</p>
</li>
<li><p>v-enter-to：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。</p>
</li>
<li><p>v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</p>
</li>
<li><p>v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</p>
</li>
<li><p>v-leave-to：定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</p>
<pre><code>&lt;transition name=&quot;fade&quot;&gt;
    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;
&lt;/transition&gt;

.fade-enter-active, .fade-leave-active {
    transition: opacity .5s;
}
.fade-enter, .fade-leave-to{
    opacity: 0;
}</code></pre></li>
</ol>
<img src="/.com//transition.png">

<p>对于这些在过渡中切换的类名来说，如果使用一个没有名字的 transition，则 v- 是这些类名的默认前缀。如果使用了 transition name=”my-transition”，那么 v-enter 会替换为 my-transition-enter。</p>
<h4 id="自定义过渡的类名"><a href="#自定义过渡的类名" class="headerlink" title="自定义过渡的类名"></a>自定义过渡的类名</h4><p>可以通过以下 attribute 来自定义过渡类名：</p>
<ul>
<li>enter-class</li>
<li>enter-active-class</li>
<li>enter-to-class</li>
<li>leave-class</li>
<li>leave-active-class</li>
<li>leave-to-class</li>
</ul>
<p>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。</p>
<pre><code>&lt;transition
    name=&quot;custom-classes-transition&quot;
    enter-active-class=&quot;animated tada&quot;
    leave-active-class=&quot;animated bounceOutRight&quot;
&gt;
      &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;
&lt;/transition&gt;</code></pre><h4 id="显性的过渡持续时间"><a href="#显性的过渡持续时间" class="headerlink" title="显性的过渡持续时间"></a>显性的过渡持续时间</h4><p>可以用 transition 组件上的 duration prop 定制一个显性的过渡持续时间 (以毫秒计)：</p>
<pre><code>&lt;transition :duration=&quot;1000&quot;&gt;...&lt;/transition&gt;</code></pre><p>也可以定制进入和移出的持续时间：</p>
<pre><code>&lt;transition :duration=&quot;{ enter: 500, leave: 800 }&quot;&gt;...&lt;/transition&gt;</code></pre><h4 id="JavaScript钩子"><a href="#JavaScript钩子" class="headerlink" title="JavaScript钩子"></a>JavaScript钩子</h4><p>可以在 transtition 的 attribute 中声明 JavaScript 钩子</p>
<ol>
<li>v-on:before-enter=”beforeEnter”</li>
<li>v-on:enter=”enter”</li>
<li>v-on:after-enter=”afterEnter”</li>
<li>v-on:enter-cancelled=”enterCancelled”</li>
<li>v-on:before-leave=”beforeLeave”</li>
<li>v-on:leave=”leave”</li>
<li>v-on:after-leave=”afterLeave”</li>
<li>v-on:leave-cancelled=”leaveCancelled”</li>
</ol>
<p>这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。</p>
<p>！<a href="images/transition.png">transition</a></p>
<blockquote>
<p>当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。</p>
<p>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p>
</blockquote>
<h4 id="过渡模式"><a href="#过渡模式" class="headerlink" title="过渡模式"></a>过渡模式</h4><p>transition 的默认行为 - 进入和离开同时发生。<br>同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了过渡模式<em>mode</em></p>
<ul>
<li><p>in-out：新元素先进行过渡，完成之后当前元素过渡离开。</p>
</li>
<li><p>out-in：当前元素先进行过渡，完成之后新元素过渡进入。</p>
<pre><code>&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;
    &lt;!-- ... the buttons ... --&gt;
&lt;/transition&gt;</code></pre></li>
</ul>
<h4 id="多个组件的过渡"><a href="#多个组件的过渡" class="headerlink" title="多个组件的过渡"></a>多个组件的过渡</h4><p>多个组件的过渡简单很多 - 不需要使用 key attribute。相反，只需要使用动态组件：</p>
<pre><code>&lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt;
      &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/transition&gt;</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/22/Vue%20API%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pr_Song">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pr_Song's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/22/Vue%20API%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Vue API 学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-22 09:57:47 / 修改时间：16:49:36" itemprop="dateCreated datePublished" datetime="2020-07-22T09:57:47+08:00">2020-07-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote>
<p><a href="#vueconfig">全局配置</a></p>
</blockquote>
<h2 id="全局配置-Vue-config"><a href="#全局配置-Vue-config" class="headerlink" title="全局配置(Vue.config)"></a>全局配置(Vue.config)</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/17/es6%E5%B8%B8%E7%94%A8%E5%8F%88%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pr_Song">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pr_Song's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/17/es6%E5%B8%B8%E7%94%A8%E5%8F%88%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">es6常用又强大的新特性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-17 15:45:43" itemprop="dateCreated datePublished" datetime="2020-07-17T15:45:43+08:00">2020-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-20 16:49:19" itemprop="dateModified" datetime="2020-07-20T16:49:19+08:00">2020-07-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#目录</p>
<blockquote>
<ol>
<li><a href="#let">let</a></li>
<li><a href="#scoping">块级作用域</a></li>
<li><a href="#const">const</a></li>
<li><a href="#destructuring">解构赋值</a></li>
<li><a href="#template-string">模板字符串</a></li>
<li><a href="#default-parameter">函数参数的默认值</a></li>
<li><a href="#rest">rest</a></li>
<li><a href="#arrow-function">箭头函数</a></li>
<li><a href="#spread">拓展运算符</a></li>
</ol>
</blockquote>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>####块级变量</p>
<p>let与var用法类似，但let声明的变量只在let命令所在的代码块内有效</p>
<pre><code>{
    let a = 1;
    var b = 2;
}
a // ReferenceError: a is not defined
b // 2</code></pre><p>####不存在变量提升</p>
<p>let声明的变量不会发生变量提升，即声明前引用会报错</p>
<pre><code>console.log(a) // ReferenceError
let a = 1;

console.log(b) // undefined
var b = 2;</code></pre><p>####暂时性死区</p>
<p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<pre><code>var tmp = 123;

if (true) {
    tmp = &apos;abc&apos;; // ReferenceError
    let tmp;
}</code></pre><h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p>let不允许在相同作用域内，重复声明同一个变量。</p>
<pre><code>let a;
let a; // 报错</code></pre><h3 id="块级作用域（scoping）"><a href="#块级作用域（scoping）" class="headerlink" title="块级作用域（scoping）"></a>块级作用域（scoping）</h3><h4 id="ES6的块级作用域"><a href="#ES6的块级作用域" class="headerlink" title="ES6的块级作用域"></a>ES6的块级作用域</h4><p>let为js提供了块级作用域，外层代码不受内层代码影响，内层代码可以引用外层变量</p>
<pre><code>{
    let a = 1;
    let b = 2;
    {
        let a = 3
        let c = 4
        console.log(a) // 3
        console.log(b) // 2
    }
    console.log(a) // 1
    console.log(c) // 报错
}</code></pre><h4 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h4><p>ES6引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。函数声明类似于var，即会提升到全局作用域或函数作用域的头部，函数声明还会提升到所在的块级作用域的头部。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。const一旦声明变量，就必须立即初始化，不能留到以后赋值。const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<pre><code>const a; // 报错
console.log(b); // 报错
const b = 1</code></pre><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<pre><code>const a = {};

a.prop = 1;
console.log(a); // { prop: 1 }

a = { prop: 1 } // 报错</code></pre><h3 id="解构赋值-Destructuring"><a href="#解构赋值-Destructuring" class="headerlink" title="解构赋值(Destructuring)"></a>解构赋值(Destructuring)</h3><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><p>这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。如果解构不成功，变量的值就等于undefined。另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<pre><code>let [a, b, c] = [1, 2, 3];

//等价于
let a = 1;
let b = 2;
let c = 3;

//解构不成功
let [foo] = []; // foo = undefined

//不完全解构
let [a, b] = [1, 2, 3]; // a = 1, b = 2</code></pre><p>如果等号的右边不是数组(或者严格地说，不是可遍历的结构)，那么将会报错。</p>
<pre><code>//报错
let [a] = 1;
let [a] = false;
let [a] = NaN;
let [a] = undefined;
let [a] = null;
let [a] = {};</code></pre><h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><p>对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<pre><code>let { a, b } = { b: 1, a: 2 } // a = 2, b = 1
let { a } = { b: 1 } // a = undefined</code></pre><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>
<pre><code>let { log, sin, cos } = Math; // 将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上</code></pre><h4 id="解构赋值允许指定默认值。ES6-内部使用严格相等运算符（-），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。"><a href="#解构赋值允许指定默认值。ES6-内部使用严格相等运算符（-），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。" class="headerlink" title="解构赋值允许指定默认值。ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。"></a>解构赋值允许指定默认值。ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</h4><pre><code>let [a, b = 2] = [1]; // a = 1, b = 2
let [a = 1] = [undefined]; // a = 1
let [a = 1] = [null]; // a = null
let { a = 1 } = {} // a = 1</code></pre><h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h4><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<pre><code>let [a, b, c, d, e] = &apos;hello&apos;; // a = &apos;h&apos;, b = &apos;e&apos;, c = &apos;l&apos;, d = &apos;l&apos;, e = &apos;o&apos;</code></pre><p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
<pre><code>let { length: len } = &apos;hello&apos;; // len = 5</code></pre><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol>
<li><p>交换变量值</p>
<pre><code>let x = 1;
let y = 2;
[x, y] = [y, x];</code></pre></li>
<li><p>取出函数返回的多个值</p>
<pre><code>function f() {
    return [1, 2, 3]
}
let [a, b, c] = f();</code></pre></li>
<li><p>提取JSON数据</p>
<p> <strong>解构赋值对提取 JSON 对象中的数据，尤其有用。</strong></p>
<pre><code>let jsonData = {
    id: 42,
    status: &quot;OK&quot;,
    data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309]</code></pre></li>
<li><p>函数默认值</p>
<p> 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p>
<pre><code>jQuery.ajax = function (url, {
    async = true,
    beforeSend = function () {},
    cache = true,
    complete = function () {},
    crossDomain = false,
    global = true,
    // ... more config
} = {}) {
    // ... do stuff
};</code></pre></li>
<li><p>输入模块的指定方法</p>
<p> 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<pre><code>const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);</code></pre></li>
</ol>
<h3 id="模板字符串-template-string"><a href="#模板字符串-template-string" class="headerlink" title="模板字符串(template string)"></a>模板字符串(template string)</h3><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。可以使用trim方法消除首尾的换行。模板字符串中嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性，还能调用函数。</p>
<pre><code>let a = &apos;hello&apos;;
console.log(`${ a }, es6`); // hello, es6</code></pre><h3 id="函数参数的默认值-Default-Parameter"><a href="#函数参数的默认值-Default-Parameter" class="headerlink" title="函数参数的默认值(Default Parameter)"></a>函数参数的默认值(Default Parameter)</h3><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre><code>function log(x, y = &apos;World&apos;) {
    console.log(x, y);
}

log(&apos;Hello&apos;) // Hello World
log(&apos;Hello&apos;, &apos;China&apos;) // Hello China
log(&apos;Hello&apos;, &apos;&apos;) // Hello</code></pre><p>参数变量是默认声明的，所以不能用let或const再次声明。使用参数默认值时，函数不能有同名参数。</p>
<pre><code>function foo(x = 5) {
    let x = 1; // error
    const x = 2; // error
}

function foo(x, x, y) {} // 不报错
function foo(x, x, y = 1) {} //报错</code></pre><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<pre><code>function foo({x, y = 5}) {
    console.log(x, y);
}

foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property &apos;x&apos; of undefined</code></pre><p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p>
<pre><code>function foo({x, y = 5} = {}) {
      console.log(x, y);
}

foo() // undefined 5</code></pre><p>常用于http请求封装</p>
<pre><code>function fetch(url, { body = &apos;&apos;, method = &apos;GET&apos;, headers = {} } = {}) {
      console.log(method);
}

fetch(&apos;http://example.com&apos;) // &quot;GET&quot;</code></pre><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre><code>let x = 1;

function f(x, y = x) {
     console.log(y);
}

f(2) // 2

function f(y = x) {
      let x = 2;
      console.log(y);
}

f() // 1</code></pre><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个<strong>数组</strong>，该变量将多余的参数放入数组中。</p>
<pre><code>// arguments变量的写法
function sortNumbers() {
      return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) =&gt; numbers.sort();</code></pre><h3 id="箭头函数-Arrow-Function"><a href="#箭头函数-Arrow-Function" class="headerlink" title="箭头函数(Arrow Function)"></a>箭头函数(Arrow Function)</h3><p>ES6 允许使用“箭头”（=&gt;）定义函数。如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<pre><code>var f = v =&gt; v;

// 等同于
var f = function (v) {
      return v;
};

// 报错
let getTempItem = id =&gt; { id: id, name: &quot;Temp&quot; };

// 不报错
let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });</code></pre><p>箭头函数有几个使用注意点。</p>
<ol>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是不可以使用new命令。</li>
<li>不可以使用arguments对象，可以用rest参数代替。</li>
<li>不可以使用yield命令</li>
</ol>
<h3 id="扩展运算符-spread"><a href="#扩展运算符-spread" class="headerlink" title="扩展运算符(spread)"></a>扩展运算符(spread)</h3><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<pre><code>console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)</code></pre><h4 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h4><ol>
<li><p>复制数组</p>
<pre><code>const a1 = [1, 2];
// 写法一
const a2 = [...a1];
// 写法二
const [...a2] = a1;</code></pre></li>
<li><p>合并数组</p>
<pre><code>const a1 = [1, 2];
const a2 = [3, 4];
[...a1, ...a2] // 1, 2, 3, 4</code></pre><p> 注意： 1， 2 方法都是浅拷贝</p>
</li>
<li><p>实现了Iterator接口的对象</p>
<p> 任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/16/Sass%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pr_Song">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pr_Song's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/16/Sass%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/" class="post-title-link" itemprop="url">Sass学习手册</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-16 20:30:22" itemprop="dateCreated datePublished" datetime="2020-07-16T20:30:22+08:00">2020-07-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-17 14:17:27" itemprop="dateModified" datetime="2020-07-17T14:17:27+08:00">2020-07-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#1">变量</a></li>
<li><a href="#2">嵌套</a></li>
<li><a href="#3">导入SASS文件</a></li>
<li><a href="#4">静默注释</a></li>
<li><a href="#5">混合器</a></li>
</ol>
<h3 id="1">变量</h3>

<p>已$开头命名变量</p>
<pre><code>$default-color: #fff;
$default-border: 1px solid $default-color;
div {
    color: $default-color;
    border: $default-border;
}

//编译后

div {
    color: #fff;
    border: 1px solid #fff;
}</code></pre><h3 id="2">嵌套</h3>

<ol>
<li><p>可以在规则块中嵌套规则块</p>
<pre><code>#content {
    h1 {}
    p {
        span: {}
    }
}

//编译后

#content h1 {}
#content p {}
#content p span {}</code></pre></li>
<li><p>父选择器标识符&amp;:当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是&amp;被父选择器直接替换：</p>
<pre><code>a {
    &amp;:hover {}
}

//编译后

a {}
a:hover {}</code></pre></li>
<li><p>群组选择器嵌套</p>
<pre><code>#content {
    h1, h2, p {}
}

//编译后

#content h1, #content h2, #content p {}</code></pre></li>
<li><p>子组合选择器和同层组合选择器：&gt;、+和~</p>
<p> 用子组合选择器&gt;选择一个元素的直接子元素</p>
<pre><code>//选择article元素内第一个section子元素
article &gt; section {
    color: red;
}</code></pre><p> 用同层相邻组合选择器+选择一个元素后紧跟的兄弟元素</p>
<pre><code>//选择紧跟header元素后的p元素
header + p {
    color: red;
}</code></pre><p> 用同层全体组合选择器~选择所有跟在一个元素后的同层元素</p>
<pre><code>//选择全体跟article后的同层p元素
article ~ p {
    color: red;
}</code></pre></li>
<li><p>选择器嵌套</p>
<pre><code>article {
    ~ p {}
    &gt; p {}
    dl &gt; {
        dt {}
        dd {}
    }
    nav + &amp; {}
}

//编译后

article ~ p {}
article &gt; p {}
article dl &gt; dt {}
article dl &gt; dd {}
nav + article {}</code></pre></li>
<li><p>属性嵌套</p>
<pre><code>div {
    border: 1px solid #333 {
        left: 0px;
        bottom: 0px;
    }
}

//编译后

div {
    border: 1px solid #333;
    border-left: 0px;
    border-bottom: 0px;
}</code></pre></li>
</ol>
<h3 id="3">导入SASS文件</h3>

<ol>
<li><p>使用SASS部分文件</p>
<p> 当通过@import把sass样式分散到多个文件时，通常只想生成少数几个css文件。那些专门为@import命令而编写的sass文件，并不需要生成对应的独立css文件，这样的sass文件称为局部文件。sass局部文件的文件名以下划线开头。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。@import一个局部文件时，可以省略文件名开头的下划线。</p>
</li>
<li><p>默认变量名</p>
<p> 重复声明一个变量时，只有最后一处声明有效且它会覆盖前边的值。!default用于变量，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。</p>
</li>
<li><p>嵌套导入</p>
<p> sass允许@import命令写在css规则内。这种导入方式下，生成对应的css文件时，局部文件会被直接插入到css规则内导入它的地方。</p>
<pre><code>//_blue-theme.sass
aside {
    background: blue;
    color: white;
}

//导入到一个css规则内
.blue-theme {
    @import &quot;blue-theme&quot;;
}

//编译后
.blue-them {
    aside {
        background: blue;
        color: white
    }
}</code></pre></li>
</ol>
<h3 id="4">静默注释</h3>

<p>sass另外提供了一种不同于css标准注释格式的注释语法，即静默注释，其内容不会出现在生成的css文件中。它们以//开头，注释内容直到行末。</p>
<h3 id="5">混合器</h3>

<p>混合器使用@mixin标识符定义。这个标识符给一大段样式赋予一个名字，这样就可以轻易地通过引用这个名字重用这段样式。然后就可以在样式表中通过@include来使用这个混合器，放在希望的任何地方。通过使用参数，可以使用混合器把样式中的通用样式抽离出来，然后轻松地在其他地方重用。实际上，混合器太好用了，一不小心可能会过度使用。大量的重用可能会导致生成的样式表过大，导致加载缓慢。</p>
<pre><code>@mixin rounded-corners {
    -moz-border-radius: 5px;
    -webkit-border-radius: 5px;
    border-radius: 5px;
}

.notice {
    background-color: green;
    border: 2px solid #00aa00;
    @include rounded-corners;
}

//编译后
.notice {
    background-color: green;
    border: 2px solid #00aa00;
    -moz-border-radius: 5px;
    -webkit-border-radius: 5px;
    border-radius: 5px;
}</code></pre><ol>
<li><p>混合器的使用场景</p>
<p> 判断一组属性是否应该组合成一个混合器，一条经验法则就是能否为这个混合器想出一个好的名字。如果能找到一个很好的短名字来描述这些属性修饰的样式，那么往往能够构造一个合适的混合器。</p>
</li>
<li><p>混合器中的CSS规则</p>
<p> 混合器中不仅可以包含属性，也可以包含css规则，包含选择器和选择器中的属性，当一个包含css规则的混合器通过@include包含在一个父规则中时，在混合器中的规则最终会生成父规则中的嵌套规则。</p>
<pre><code>@mixin no-bullets {
    list-style: none;
    li {
        list-style-image: none;
        list-style-type: none;
        margin-left: 0px;
    }
}

ul.plain {
    color: #444;
    @include no-bullets;
}

//编译后
ul.plain {
    color: #444;
    list-style: none;
}
ul.plain li {
    list-style-image: none;
    list-style-type: none;
    margin-left: 0px;
}</code></pre></li>
<li><p>给混合器传参</p>
<p> 混合器并不一定总得生成相同的样式。可以通过在@include混合器时给混合器传参，来定制混合器生成的精确样式。当@include混合器时，参数其实就是可以赋值给css属性值的变量。</p>
<pre><code>@mixin link-colors($normal, $hover, $visited) {
    color: $normal;
    &amp;:hover { color: $hover; }
    &amp;:visited { color: $visited; }
}

a {
    @include link-colors(blue, red, green);
}

//编译后
a { color: blue; }
a:hover { color: red; }
a:visited { color: green; }</code></pre><p> sass允许通过语法$name: value的形式指定每个参数的值。这种形式的传参，参数顺序就不必再在乎了，只需要保证没有漏掉参数即可</p>
<pre><code>a {
    @include link-colors(
        $normal: blue,
        $visited: green,
        $hover: red
    )
}</code></pre></li>
<li><p>默认参数值</p>
<p> 为了在@include混合器时不必传入所有的参数，可以给参数指定一个默认值。参数默认值使用$name: default-value的声明形式，默认值可以是任何有效的css属性值，甚至是其他参数的引用。</p>
<pre><code>@mixin link-colors(
    $normal,
    $hover: $normal,
    $visited: $normal
)
{
    color: $normal;
    &amp;:hover { color: $hover; }
    &amp;:visited { color: $visited; }
}

a{
    @include link-colors(red);
}

//编译后
a { color: red; }
a:hover { color: red; }
a:visited { color: red; }</code></pre></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/16/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pr_Song">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pr_Song's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/16/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">markdown语法学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-16 09:24:39" itemprop="dateCreated datePublished" datetime="2020-07-16T09:24:39+08:00">2020-07-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-17 14:15:13" itemprop="dateModified" datetime="2020-07-17T14:15:13+08:00">2020-07-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一级标题 # == h1<br>二级标题 ## == h2<br>三级标题 ### == h3<br>四级标题 #### == h4<br>五级标题 ##### == h5<br>六级标题 ###### == h6</p>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>标题与段落间要空行</p>
<p>段落与段落间空行，尤其是多行段落不空行会直接加到后面  </p>
<p>不要用空格（spaces）或制表符（ tabs）缩进段落</p>
<p>在一行的末尾添加两个或多个空格，然后按回车键（return），即可创建一个换行（line break） == br，<br>用于同一段落的换行，不同段落间用空行分隔</p>
<h2 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h2><p>在单词或短语的前后各添加两个星号**或下划线__来<strong>加粗文本</strong></p>
<p>在单词或短语前后添加一个星号*或下划线_来<em>表示斜体</em></p>
<p>在单词或短语的前后各添加三个星号***或下划线___来<strong><em>加粗斜体</em></strong></p>
<h2 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h2><p>要创建块引用，请在段落前添加一个 &gt; 符号。</p>
<blockquote>
<p>像这样</p>
</blockquote>
<p>块引用可以包含多个段落。为段落之间的空白行各添加一个 &gt; 符号。</p>
<blockquote>
<p>像这样</p>
<p>像这样</p>
</blockquote>
<p>块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。</p>
<blockquote>
<p>像这样</p>
<blockquote>
<p>像这样</p>
</blockquote>
</blockquote>
<p>块引用可以包含其他 Markdown 格式的元素。</p>
<blockquote>
<ul>
<li>像这样</li>
<li>像这样</li>
</ul>
<p><em>像这样</em>，<strong>像这样</strong></p>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>每个列表项前添加数字并紧跟一个英文句点创建有序列表</p>
<ol>
<li>像这样</li>
<li>像这样</li>
<li>像这样</li>
</ol>
<p>在每个列表项前面添加破折号、星号或加号创建无序列表</p>
<ul>
<li>像这样</li>
</ul>
<ul>
<li>像这样</li>
</ul>
<ul>
<li>像这样</li>
</ul>
<p>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符</p>
<ol>
<li><p>像这样</p>
<blockquote>
<p>像这样</p>
</blockquote>
</li>
<li><p>像这样</p>
</li>
<li><p>像这样</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>要将单词或短语表示为代码，请将其包裹在反引号 (`) 中</p>
<p>像这样 </p>
<p><code>let hello = &#39;markdown&#39;</code><br><code>console.log(&#39;hello&#39;, hello)</code></p>
<h2 id="创建代码块"><a href="#创建代码块" class="headerlink" title="创建代码块"></a>创建代码块</h2><p>将代码块的每一行缩进至少四个空格或一个制表符</p>
<pre><code>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
&lt;/html&gt;</code></pre><p>在单独一行上使用三个或多个星号、破折号或下划线，并且不能包含其他内容，创建分割线，分隔线的前后均添加空白行</p>
<hr>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>将链接文本括在方括号中，然后立即在URL后面加上括号</p>
<blockquote>
<p>像这样 <a href="https://https://songpurong.github.io/" target="_blank" rel="noopener">Pr_Song’s Blog</a></p>
</blockquote>
<p>要将URL或电子邮件地址快速转换为链接，请将其括在尖括号中</p>
<blockquote>
<p><a href="https://https://songpurong.github.io/" target="_blank" rel="noopener">https://https://songpurong.github.io/</a><br><a href="mailto:&#x35;&#x30;&#x36;&#52;&#x33;&#57;&#53;&#x30;&#48;&#x40;&#113;&#113;&#46;&#x63;&#111;&#x6d;">&#x35;&#x30;&#x36;&#52;&#x33;&#57;&#53;&#x30;&#48;&#x40;&#113;&#113;&#46;&#x63;&#111;&#x6d;</a></p>
</blockquote>
<p>为了强调链接，在方括号和括号之前和之后添加星号</p>
<blockquote>
<p>像这样 <strong><a href="https://https://songpurong.github.io/" target="_blank" rel="noopener">Pr_Song’s Blog</a></strong>.<br>像这样 <em><a href="https://https://songpurong.github.io/" target="_blank" rel="noopener">Pr_Song’s Blog</a></em>.</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/15/hexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pr_Song">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pr_Song's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/15/hexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">hexo使用指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-15 15:54:01 / 修改时间：15:56:21" itemprop="dateCreated datePublished" datetime="2020-07-15T15:54:01+08:00">2020-07-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>hexo new “name”       # 新建文章<br>hexo new page “name”  # 新建页面<br>hexo g                # 生成页面<br>hexo d                # 部署<br>hexo g -d             # 生成页面并部署<br>hexo s                # 本地预览<br>hexo clean            # 清除缓存和已生成的静态文件<br>hexo help             # 帮助</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Pr_Song</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pr_Song</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
